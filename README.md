# ACWing

上课：算法理解

课下：1. 理解并记忆算法模板（可以写出来并调试通过）

​			2. 题目，一个题目三到五遍

# 排序

## 快速排序

思想：分而治之。

- 先确立分界点（取左边界q[i]，中间值q[(l+r)/2]，随机取）；
- 调整区间，使得边界左边的小于等于，边界右边的大于；（难点）
- 递归处理左边和右边。

做法：用两个指针i j在两边向中间走，如果i小于，就向右移动；如果遇到不小于，就停下；右边j也一样。交换i和j指向的数。直到两个数相遇为止。

### 快速选择

利用快排找出第k个数。根据快速排序的思想选出一轮后，分界线左边的数量为j，**因为J一定是左半边区间的最后一个**。如果j<=k，说明要找的数在左边，只递归左边[l,j]，反之递归右边[j+1,r]。

复杂度分析：一共进行n(1+1/2+1/4+...)<2n次，故时间复杂度为 O(n)。

## 归并排序

也是分治思想

- 确定分界点：mid=(l+r)/2
- 递归排序左边和右边
- 合并

### 逆序对

基于归并排序的思想（分治）处理逆序对：逆序对的数量=左边+右边+横跨

当左边q[i]大于q[j]，那么q[i]后面的数也一定大于q[j]。数量为mid-i+1。

# 二分

## 整数二分

二分的实质：在一个数组中，一部分满足某个条件，另一部分不满足这个条件，那么使用二分法可以找到这两个部分的分界点。

假设寻找一个数在有序数组中的范围。

1. 查找左起点，考虑nums[mid]=true的情况，需要继续向左找，并包含mid，因此更新方式为r=mid，或者nums[mid]=false，l=mid+1。在考虑继续向左找的另一种情况是nums[mid]>target，因此

   `if (q[mid] >= x) r = mid;  else l = mid + 1;`

   此时`mid=r+l>>1`。

2. 查找右起点，考虑nums[mid]=true的情况，需要继续向右找，并包含mid，因此更新方式为l=mid，或者nums[mid]=false，r=mid-1。在考虑继续向右找的另一种情况是nums[mid]<target，因此

   `if (q[mid] <= x) l = mid;  else r = mid - 1;`

   此时`mid=r+l+1>>1`。

   **注意l=mid的情况，需要补偿+1。可以这么记：l和1很像。特判：l=r-1**

## 实数二分

设置一个eta，当r-l>eta，继续二分。

# 高精度

## 高精度加法

正序读入一个数，然后倒序存储，例如123存储时为321，下标0代表最低位。用一个k代表进位，每一位运算后结果push(k%10)，k/=10。遍历完原数组后，如果k不为0，继续push(k)。

## 高精度减法

首先假定A>=B。有一个借位t。`Ai-Bi-t`>=0的话直接写，<=0的话+10并借位。

A和B比大小：先比较size，若size相同从最高位开始比较。

## 高精度乘法

结果的每一位是(t+A[i]\*b)%10，进位是(t+A[i]\*b)/10。

## 高精度除法

在进行除法的时候，先要找到能除掉除数的数。这个过程可以由一个r实现。初始r=0，从高位遍历被除数A[i]，r=r*10+A[i]，ans.push_back(r/10)，r%-=10。最后去掉ans的先导0。这个r正好剩下的余数。
