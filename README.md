# ACWing

上课：算法理解

课下：1. 理解并记忆算法模板（可以写出来并调试通过）

​			2. 题目，一个题目三到五遍

# 排序

## 快速排序

思想：分而治之。

- 先确立分界点（取左边界q[i]，中间值q[(l+r)/2]，随机取）；
- 调整区间，使得边界左边的小于等于，边界右边的大于；（难点）
- 递归处理左边和右边。

做法：用两个指针i j在两边向中间走，如果i小于，就向右移动；如果遇到不小于，就停下；右边j也一样。交换i和j指向的数。直到两个数相遇为止。

### 快速选择

利用快排找出第k个数。根据快速排序的思想选出一轮后，分界线左边的数量为j，**因为J一定是左半边区间的最后一个**。如果j<=k，说明要找的数在左边，只递归左边[l,j]，反之递归右边[j+1,r]。

复杂度分析：一共进行n(1+1/2+1/4+...)<2n次，故时间复杂度为 O(n)。

## 归并排序

也是分治思想

- 确定分界点：mid=(l+r)/2
- 递归排序左边和右边
- 合并

### 逆序对

基于归并排序的思想（分治）处理逆序对：逆序对的数量=左边+右边+横跨

当左边q[i]大于q[j]，那么q[i]后面的数也一定大于q[j]。数量为mid-i+1。

# 二分

## 整数二分

二分的实质：在一个数组中，一部分满足某个条件，另一部分不满足这个条件，那么使用二分法可以找到这两个部分的分界点。

假设寻找一个数在有序数组中的范围。

1. 查找左起点，考虑nums[mid]=true的情况，需要继续向左找，并包含mid，因此更新方式为r=mid，或者nums[mid]=false，l=mid+1。在考虑继续向左找的另一种情况是nums[mid]>target，因此

   `if (q[mid] >= x) r = mid;  else l = mid + 1;`

   此时`mid=r+l>>1`。

2. 查找右起点，考虑nums[mid]=true的情况，需要继续向右找，并包含mid，因此更新方式为l=mid，或者nums[mid]=false，r=mid-1。在考虑继续向右找的另一种情况是nums[mid]<target，因此

   `if (q[mid] <= x) l = mid;  else r = mid - 1;`

   此时`mid=r+l+1>>1`。

   **注意l=mid的情况，需要补偿+1。可以这么记：l和1很像。特判：l=r-1**

## 实数二分

设置一个eta，当r-l>eta，继续二分。

## 高精度

### 高精度加法

正序读入一个数，然后倒序存储，例如123存储时为321，下标0代表最低位。用一个k代表进位，每一位运算后结果push(k%10)，k/=10。遍历完原数组后，如果k不为0，继续push(k)。

### 高精度减法

首先假定A>=B。有一个借位t。`Ai-Bi-t`>=0的话直接写，<=0的话+10并借位。

A和B比大小：先比较size，若size相同从最高位开始比较。

### 高精度乘法

结果的每一位是(t+A[i]\*b)%10，进位是(t+A[i]\*b)/10。

### 高精度除法

在进行除法的时候，先要找到能除掉除数的数。这个过程可以由一个r实现。初始r=0，从高位遍历被除数A[i]，r=r*10+A[i]，ans.push_back(r/10)，r%-=10。最后去掉ans的先导0。这个r正好剩下的余数。

## 前缀和

`S0=0`，从1开始。统一为`S[i]=S[i]-S[0]`。

最主要的作用是可以O(1)时间算出[l,r]的和。`s[r]=s[l-1]`

### 子矩阵的和

S(x,y)表示x，y坐标左上的矩阵的和.

初始化：
$$
S(i,j)=S(i-1,j)+S(i,j-1)-S(i-1,j-1)+a_{ij}
$$
那么`(x1,y1) (x2,y2)`表示的矩阵的和为
$$
S(x_2,y_2)-S(x_2,y_1-1)-S(x_1-1,y_2)+S(x_1-1,y_1-1)
$$

### 差分

对一个差分数组求前缀和会得到原数组。

对于原数组a ，在`[l, r]`区间全部加一个C，暴力需要O(n)的时间，但用差分，对`b[l]+C，b[r+1]-C`就可以在O(1)得到（对b求前缀和还是O(n)）。

### 差分矩阵

构造差分矩阵b，使得`a[i][j]`是`b[i][j]`左上角的和。

`a[x1,y1]`到`a[x2,y2]`区间+c，反映到`b[x1,y1]+C`，`b[x2+1,y1]-C`，`b[x1,y2+1]-C`，`b[x2+1,y2+1]+C`

构造差分矩阵的时候，每有一个`a[i,j]`，可以认为是向b数组[i,j]到[i,j]这个1*1矩阵添加了一个C。

## 双指针

双指针有两种形式：一种是两个指针分别在两个数组上运行，一种是两个指针在一个数组中运行。

### 最长连续不重复子序列

两个指针i和j，i是终点为j的最长不重复子序列的开头。当j向右移动，i不可能向左移动，具有单调性。

当i==j，说明需要重新开始找。

```C++
for(int i=0,j=0;j<n;j++){
    while(i<j && check(i,j))	j++;
    res=max(j-i+1,res);
}
```

check的方法：开一个数组记录元素出现的次数，如果s[q[j]]>1就说明出现重复。

## 位运算

### 二进制位1的个数

向右移k位，看是否为奇数。（方法：(x>>k)&1，这个操作可以查看第k位的数字是什么）

另一种方法：x每次减去lowbit(x)

```C++
int res=0;
while(x){
    x-=lowbit(x);
    res++;
}
```

### lowbit(x)

这个操作是返回数的最后一位1，例如1010返回10，101000返回1000

操作：x&-x

## 离散化

当数据的范围很大，但用到的很少，可以用离散化的方法，类似于一个hash表的过程，映射。

## 区间合并

给出几个区间的起始点，将他们有交集的部分进行合并。

先根据左端点进行排序，然后扫描：第二个区间和第一个区间有三种关系

- 包含，不更新ed
- 交集，更新ed
- 没有交集，将维护区间改为新的区间
